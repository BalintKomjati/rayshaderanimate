---
title: Make a video from a GPX file
output:
  pdf_document
author: "[Sebastian Wolf](mailto:sebastian@mail-wolf.de)"
date: "18 Oct 2019"
vignette: >
  %\VignetteIndexEntry{rayshaderanimate}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Introduction

This tutorial will go through the basic steps that are implemented within rayshaderanimate. The main functionality
of the package is animating a GPX line on a 3d shade of an elevation profile.

Thus the tutorial will

- Read in a GPX line
- Download elevation data around this GPX file
- Download a map overlay for the GPX file
- Plot the elevation map in 2D to check the data
- Create a 3d animated gif
- Create a 3d animated mp4 (more frames possible)

# Read in a GPX file

Reading in a GPX file is handled by the `plotKML::readGPX` function. It is automatically loaded
by `rayshaderanimate` and used inside the `get_table_from_gpx` function. From this table the
boundaries of the GPX file will be read in a standard `bbox` format as used e.g. by `ggmap`
and in a second format used for receiving data from [Arcgis](https://arcgis.com).

1. Get the GPX file location from this package

```{r, eval = TRUE, echo = FALSE}
library(rayshaderanimate)
gpx_file_loc <- system.file("Alpe_d_Huez.gpx", package="rayshaderanimate")
```

2. Get boundaries from GPX

```{r, eval = TRUE, echo = FALSE}
library(magrittr)

gpx_table <- get_table_from_gpx(gpx_file_loc) %>%
  get_enriched_gpx_table()

bbox <- get_bbox_from_gpx_table(gpx_table) 
bbox_arcgis <- get_table_from_gpx(gpx_file_loc) %>% get_bbox_from_gpx_table(arcgis = TRUE)
```

# Paint a map

To see if the right bbox was calculated, you can use the `bbox_map` function to simply double
check the location. In this case you should see a map of the French alps around
Alpe d'Huez.

```{r, eval = TRUE, echo = TRUE}
bbox_map(bbox)
```

# Receive elevation data

The elevaton data will be received from [SRTM](http://srtm.csi.cgiar.org/srtmdata/). As SRTM provides
only 5 degree x 5 degree sectors, the data is filtered for the `bbox`. Afterwards this data can be
converted into a long format to use it in ggplot or into a matrix without any labels that can 
easily be used in standard [rayshader](https://github.com/tylermorganwall/rayshaderâ€ƒ
) functions.


```{r, eval = FALSE, echo = TRUE}
el_mat <- bbox %>% get_elevdata_from_bbox()

# Use data from EUDEM project available at: https://land.copernicus.eu/imagery-in-situ/eu-dem/eu-dem-v1.1
el_mat <- get_elevdata_from_bbox(bbox = bbox, type ="EUDEM", file = "eu_dem_v11_E40N20/eu_dem_v11_E40N20.TIF")
```

```{r, eval = TRUE, echo = TRUE}
data(el_mat) # load pre-stored data
elmat_rayshade <- el_mat %>% unlabel_elevdata()
elmat_long <- get_elevdata_long(el_mat)
```

# Plot 2D with map overlay

To double check the data is the right elevation data, it will be plotted. You should
see the shades of mountains where you would expect them.

```{r, eval = TRUE, echo = TRUE}
# in case of EUDEM data you might need to transpose the elmat_rayshade
plot_2d_elevdata(elevdata_rayshade = elmat_rayshade)
```

# Generate 3D video

The most important step of this package is the generation of a 3D video. The video generation works the following way:

1. A `geom_tile` plot is generated from the elevation data
2. The GPX line is painted on this elevation map
3. A 3D model of the landscape is generated by `plot_gg` from [rayshader](https://github.com/tylermorganwall/rayshader).
4. A snapshot is taken

The procedure is repeated `number_of_screens` times. In each step the GPX line is painted a bit further.

The main length of the line is calculated such that the intervals between snapshots have a similar time difference
to generate a movie feeling.

On more than 50 screens the animation will look from different angles and different zooms on the 3D model.

All snapshots get rendered into a `gif` by the [magick](https://cran.r-project.org/web/packages/magick/magick.pdf) package or
into a `mp4` by `ffmpeg`. Therefore `ffmpeg` needs to be installed and inside the `PATH`.


```{r, eval = FALSE, echo = TRUE}
output_gif <- video_animation(gpx_table = gpx_table, elevdata_long = elmat_long, make_gif = TRUE, number_of_screens = 5,
                output_file_loc = tempfile(fileext = ".gif"))

Sys.setenv("PATH" = paste0(Sys.getenv("PATH"), ";", "<Where is ffmpeg>"))

output_vid <- video_animation(gpx_table = gpx_table, elevdata_long = elmat_long, make_gif = FALSE, number_of_screens = 6,
                output_file_loc = tempfile(fileext = ".mp4"))
```

